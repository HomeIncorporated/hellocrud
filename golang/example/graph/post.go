// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package graph

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/choonkeat/hellocrud/golang/example/dbmodel"
	graphql "github.com/graph-gophers/graphql-go"
	"github.com/pkg/errors"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries/qm"
)

// Post is an object to back GraphQL type
type Post struct {
	model dbmodel.Post
	db    boil.Executor
}

// GraphQL friendly getters

func (o Post) RowID() string {
	return fmt.Sprintf("Post%d", o.model.ID) // int
}
func (o Post) ID() graphql.ID {
	return graphql.ID(fmt.Sprintf("%d", o.model.ID)) // int
}
func (o Post) Title() string {
	return o.model.Title // string
}
func (o Post) Author() string {
	return o.model.Author // string
}
func (o Post) Body() string {
	return o.model.Body // string
}
func (o Post) Notes() *string {
	return o.model.Notes.Ptr() // null.String
}
func (o Post) CreatedAt() *graphql.Time {
	if o.model.CreatedAt.Valid {
		return &graphql.Time{Time: o.model.CreatedAt.Time}
	}
	return nil // null.Time
}
func (o Post) UpdatedAt() *graphql.Time {
	if o.model.UpdatedAt.Valid {
		return &graphql.Time{Time: o.model.UpdatedAt.Time}
	}
	return nil // null.Time
}

// Post is an object to back GraphQL type
type createPostInput struct {
	Title     string
	Author    string
	Body      string
	Notes     *string
	UpdatedAt *graphql.Time
}

// Post is an object to back GraphQL type
type updatePostInput struct {
	Title     string
	Author    string
	Body      string
	Notes     *string
	UpdatedAt *graphql.Time
}

type PostsCollection struct {
	nodes []Post
	// future meta data goes here, e.g. count
}

func (c PostsCollection) Nodes(ctx context.Context) []Post {
	return c.nodes
}

func (r *Resolver) AllPosts(ctx context.Context, args struct {
	Since    *graphql.ID
	PageSize int32
}) (PostsCollection, error) {
	result := PostsCollection{}
	mods := []qm.QueryMod{qm.Limit(int(args.PageSize))}
	if args.Since != nil {
		s := string(*args.Since)
		i, err := strconv.ParseInt(s, 10, 64)
		if err != nil {
			return result, err
		}
		mods = append(mods, qm.Offset(int(i)))
	}
	slice, err := dbmodel.Posts(r.db, mods...).All()
	if err != nil {
		return result, errors.Wrapf(err, "allPosts(%#v)", args)
	}
	for _, m := range slice {
		result.nodes = append(result.nodes, Post{model: *m, db: r.db})
	}

	return result, nil
}

func (r *Resolver) PostByID(ctx context.Context, args struct {
	ID graphql.ID
}) (Post, error) {
	result := Post{}
	i, err := strconv.ParseInt(string(args.ID), 10, 64)
	if err != nil {
		return result, errors.Wrapf(err, "PostByID(%#v)", args)
	}

	m, err := dbmodel.FindPost(r.db, int(i))
	if err != nil {
		return result, errors.Wrapf(err, "PostByID(%#v)", args)
	} else if m == nil {
		return result, errors.New("not found")
	}
	return Post{model: *m, db: r.db}, nil
}

func (r *Resolver) CreatePost(ctx context.Context, args struct {
	Input createPostInput
}) (Post, error) {
	result := Post{}
	m := dbmodel.Post{}
	data, err := json.Marshal(args.Input)
	if err != nil {
		return result, errors.Wrapf(err, "json.Marshal(%#v)", args.Input)
	}
	if err = json.Unmarshal(data, &m); err != nil {
		return result, errors.Wrapf(err, "json.Unmarshal(%s)", data)
	}

	if err := m.Insert(r.db); err != nil {
		return result, errors.Wrapf(err, "createPost(%#v)", m)
	}
	return Post{model: m, db: r.db}, nil
}

func (r *Resolver) UpdatePostByID(ctx context.Context, args struct {
	ID    graphql.ID
	Input updatePostInput
}) (Post, error) {
	result := Post{}
	i, err := strconv.ParseInt(string(args.ID), 10, 64)
	if err != nil {
		return result, errors.Wrapf(err, "PostByID(%#v)", args)
	}

	m, err := dbmodel.FindPost(r.db, int(i))
	if err != nil {
		return result, errors.Wrapf(err, "updatePostByID(%#v)", args)
	} else if m == nil {
		return result, errors.New("not found")
	}
	data, err := json.Marshal(args.Input)
	if err != nil {
		return result, errors.Wrapf(err, "json.Marshal(%#v)", args.Input)
	}
	if err = json.Unmarshal(data, &m); err != nil {
		return result, errors.Wrapf(err, "json.Unmarshal(%s)", data)
	}

	if err := m.Update(r.db); err != nil {
		return result, errors.Wrapf(err, "updatePost(%#v)", m)
	}
	return Post{model: *m, db: r.db}, nil
}

func (r *Resolver) DeletePostByID(ctx context.Context, args struct {
	ID graphql.ID
}) (Post, error) {
	result := Post{}
	i, err := strconv.ParseInt(string(args.ID), 10, 64)
	if err != nil {
		return result, errors.Wrapf(err, "PostByID(%#v)", args)
	}

	m, err := dbmodel.FindPost(r.db, int(i))
	if err != nil {
		return result, errors.Wrapf(err, "updatePostByID(%#v)", args)
	} else if m == nil {
		return result, errors.New("not found")
	}
	if err := m.Delete(r.db); err != nil {
		return result, errors.Wrapf(err, "deletePostByID(%#v)", m)
	}
	return Post{model: *m, db: r.db}, nil
}
